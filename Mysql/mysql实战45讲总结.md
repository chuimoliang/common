# #Mysql实战45讲总结

> 我希望更多的能以一个问题的方式总结出这45讲的干货。

[MySQL 的 crash-safe 原理解析](https://zhuanlan.zhihu.com/p/142491549)

## 第一讲：一条SQL查询语句是如何执行的？

### 1. 一条 SQL 的执行过程时怎样的？

连接器->分析器->优化器->执行器

![image-20210821002948214](../source/img/image-20210821002948214.png)

涵盖 MySQL 的大多数核 心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎 的功能都在这一层实现，比如**存储过程、触发器、视图**等。

### 2. 如何处理 Mysql 由于长连接过多导致内存占用过大的问题？

a. 定期断开长连接。使用一段时间，**或者程序里面判断执行过一个占用内存的大查询后， 断开连接，之后要查询再重连。**

b, 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 **mysql_reset_connection** 来重新初始化连接资源。这个过程不需要重连和重新做权限验 证，但是会将连接恢复到刚刚创建完时的状态。

注： `mysql_reset_connection` 是 MySQL api

### 3.  MySQL 服务层的查询缓存会带来哪些问题？

a. 缓存更新的粒度过高，一个表更新整个缓存均失效， 这对一个压力较大的库来说是十分痛苦的，会导致命中率及其低。

b. 但也不是说没坏处，任何事有利有弊端，该缓存对静态表及其友好，（配置表）

c. MySQL 也提供了这种“按需使用”的方式。你可以将参数 `query_cache_type` 设置 成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓 存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：

```sql
select SQL_CACHE * from T where ID=10；
```

query_cache_type 支持 

0 关闭， 1 开启， 2 按需使用 

### 4.如果执行一个 SQL 语句 出现字段错误，或者说找不到字段，问题出现在服务层的哪个阶段？

我认为是优化器的，优化器会进行优化分析，比如用先执行哪个条件，使用哪个索引。如 果没有对应的字段就会报错的，我看其他评论说是执行器，原因是这个时候才打开表获取数据，但是表的字段不是数据啊，是事先定义好的，所以可以直接读取的，不需要打开表。

## 第二讲：一条更新语句是如何被执行的。

### 1. 什么是 WAL 技术？

WAL 全称为 Write Ahead Logging，指的是先写日志（buffer）再写磁盘。根据不同的策略减少 IO 的写入次数。

### 2. redo log 如何保证 crash safe？

 crash safe 指的是即使数据库发生异常重启，之前提交的记录都不会丢失。 inodb提供的 redo log也称为事务日志，由InnoDB存储引擎层产生。记录的是数据库中每个页的修改，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置，因为修改会覆盖之前的）。

### 3. bin log 是什么？有什么作用？

bin log 是 Mysql Server 实现的，所有引擎都可以使用，记录的是 sql 语句， redo log 是循环写的而 bin log 不同，bin log 是写一个文件，满了再写下一个文件。有一点需要注意， bin log 不允许一个事务的log 跨 日志文件，因此日志文件大小可能会大于 bin log 设置的最大大小。

#### 4. bin log 不是服务层的东西嘛，为什么 二阶段提交会先写 redo log？

只有引擎层执行完了才会写日志，先写 redo log 是因为 redo log 在引擎曾，然后通知服务层，我写完了，服务层再写 bin log。然后服务层的执行器通知引擎层提交事务。于是引擎把刚刚写入的 redo log 改成提交（commit）状 态，更新完成。

### 5. 怎样让数据库恢复到半个月内任意一秒的状态？

binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你 的 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天 一备，也可以是一周一备。（因此  binlog 保证了数据库的持久性。）

**谈一句，丢数据是一定的，我们有很多策略能保证减少数据丢失的量，但这是一个权衡问题**

### 6.不使用 两阶段提交会造成哪些问题？

a. 先写 redo log 后写 binlog。**假设在 redo log 写完，**binlog 还没有写完的时候， MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍 然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。 但是由于 binlog 没写完就 crash 了，**这时候 binlog 里面就没有记录这个语句。因此， 之后备份日志的时候，存起来的 binlog 里面就没有这条语句。 然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢 失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不 同。** 

b. 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写， 崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，**在之后用 binlog 来恢复**的时候就多了一个事务出来， 恢复出来的这一行 c 的值就是 1，与原库的值不同。

### 7. 第二讲提供的几个命令

redo log 用于**保证 crash-safe 能力**。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1， 这样可以保证 MySQL 异常重启之后数据不丢失。 sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参 数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。



##  第三讲：事务隔离：为什么你改了我还看不见？

### 1. 谈谈多个事务同时执行的时候，可能出现什么问题？

a. 脏读

b. 不可重复读

c.幻读

### 2. SQL标准的事务隔离级别包括哪些？

a. 读未提交： 一个事务还没提交时，它做的变更就能被别的事务看到。（不创建视图）

b. **读提交**: 一个事务提交之后，他做的变更才会被其他事务看到。（在每个SQL 语句开始执行的时候创建视图）

c. **可重复读**：一个事务执行过程中看到的数据，总是和这个事务启动的时候看到的数据一致的。（创建事务开始的时候，创建视图。）

d. 串行化： 对同一行记录，写加写锁，读加读锁。当出现锁冲突的时候，后访问的事务必须等前一个事务执行完成,才能继续执行。（加锁）

查看隔离级别

```mysql
show variables like 'transaction_isolation';
```

```tex
mysql> show variables like 'transaction_isolation';                                                                 +-----------------------+-----------------+                                                                         | Variable_name         | Value           |                                                                          +-----------------------+-----------------+                                                                          | transaction_isolation | REPEATABLE-READ |                                                                     
+-----------------------+-----------------+                                                                             1 row in set, 1 warning (0.07 sec)                                                                                                                           
```

### 3. 不同事务隔离适用的可场景有哪些？

可重复读： 对比当前银行卡余额与上个月银行卡余额的差额。 可重复读保证读的时候视图时静态的。

### 4. 事务隔离是怎么实现的？

在每条记录在更新的时候，都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，能回到前一个状态。

回滚日志会记录，每一个字段的回滚日志，如下图。

![image-20210821221640459](../source/img/image-20210821221640459.png)

不同的时刻启动的事务会有不同的 read-view。在视图 a，b，c 中对同一个记录存在不同的版本。这就是 mvcc ，对于 视图 a 要想得到1必须将当前值一次回滚。

### 5. 回滚日志应该什么时候删除呢？/为什么不推荐使用长事务？

当不需要的时候，嗯，一句废话。我从上面这个图可以看到，当 read-view 不被占用的时候，就可以被删除了。当 read-view A长时间执行，则 数据库中 对它可能用到的回滚记录，将一直保存。回滚数据占空间也就罢了，甚至可能会拖垮数据库。（在第二讲，有更详细的介绍）

### 6.  事务的启动方式有哪些？

``` mysql
# 1.显示启动
begin/ start transaction 
commit
# 2
set autocommit=0;
# 该命令将这个线程自动提交关掉，只要执行一个 select 语句 事务就启动了，事务会持续到 commit 或者 rollback 语句，或者 断开连接
# 3
commit work and chain; # 自动提交并且开始新一轮的事务
```

### 7. 如何查询长事务

```mysql
#在 information_schema 库中。
```



