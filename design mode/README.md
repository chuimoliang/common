# 几大原则

## 单一职责原则（SRP）

> 就一个类而言，应当仅有一个类能引起它的变化的原因。

如果一个类承担的责任过多，就等于将这些职责耦合在一起，一个职责的变化，可能会削弱或者抑制这个类完成其他责任的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏（ASD）。

如果你想到**多余一个动机**去改变一个类，那么这个类就具有多余一个的职责。



## 开放封闭原则

> 1. 对扩展是开放的 (open for extension)
> 2. 对更改是封闭的（closed for modification）



![image-20210808220547561](../source/img/image-20210808220547561.png)

![image-20210808220628035](../source/img/image-20210808220628035.png)

![image-20210808220704949](../source/img/image-20210808220704949.png)

![image-20210808220754703](../source/img/image-20210808220754703.png)

![image-20210808220824893](../source/img/image-20210808220824893.png)

## 依赖倒转原则

> 1. 高层模块不应该依赖底层模块，而是二者都依赖抽象
> 2. 抽象不应该依赖细节，细节应该依赖抽象



## 里氏代换原则

> 子类型必须能替换掉它的父类型



白话：一个软件实体如果使用的是一个父类，那么一定适用它的子类，而且它察觉不出父类对象和子类对象的区别。



![image-20210808222855363](../source/img/image-20210808222855363.png)



[该作者总结的几个设计模式](https://www.cnblogs.com/zyrblog/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)