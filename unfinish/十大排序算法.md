# 十大排序算法



|            | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度  | 稳定性     |
| ---------- | -------------- | -------- | -------- | ----------- | ---------- |
| *冒泡排序* | O(n²)          | O(n)     | O(n²)    | O(1)        | **稳定**   |
| *选择排序* | O(n²)          | O(n²)    | O(n²)    | O(1)        | 不稳定     |
| *插入排序* | O(n²)          | O(n)     | O(n²)    | O(1)        | 稳定       |
| 希尔排序   | O(nlogn)       | O()      | O(n²)    | O(1)        | 不稳定     |
| 归并排序   | O(nlogn)       | O(nlogn) | O(nlogn) | O(n + logn) | 稳定       |
| 快速排序   | O(nlogn)       | O(nlogn) | O(n²)    | O(logn)     | 不稳定     |
| 堆排序     | O(nlogn)       | O(nlogn) | O(nlogn) | O(1)        | **不稳定** |
| 桶排序     | O(n + k)       | O(n + k) | O(n²)    | O(n + k)    | 稳定       |
| 计数排序   | O(n + k)       | O(n + k) | O(n + k) | O(k)        | 稳定       |
| 基数排序   | O(n × m)       | O(n × m) | O(n × m) | O(n + m)    | 稳定       |



## 冒泡排序



![](..\source\img\bubbleSort.gif)

```c++
#include <algorithm>
#include <vector>

void bubbleSort(std::vector<int>& target)
{
    int len = target.size();
	for (int i = len -1; i > 0 ; i--)
	{
		bool flag = true;
		for (size_t j = 0; j +1<= i; j++)
		{
			if (target[j] > target[j + 1])
			{
				std::swap(target[j], target[j + 1]);
				flag = false;
			}
		}
		if (flag)
		{
			break;
		}
	}
}
```



## 选择排序

![img](..\source\img\selectionSort.gif)

```c++
void selectionSort(std::vector<int>& target)
{
	int len = target.size();
	for (int i = 0; i < len; i++)
	{
		for (int j = 0; j < len; j++)
		{
			if (target[i] > target[j])
			{
				std::swap(target[i], target[j]);
			}
		}
	}
}

```

# 插入排序



![img](..\source\img\insertionSort.png)



```c++
void insertionSort(std::vector<int>& target)
{
	int len = target.size();
	for (int i = 1; i < len; i++)
	{
		int temp_value = target[i];
		int j = 0;
		for (j = i - 1; j >= 0; j--)
		{
			if (target[j] > temp_value)
			{
				target[j + 1] = target[j];
				continue;
			}
			break;
		}
		target[j + 1] = temp_value;
	}
} // 你可能会想吧最后一条语句放在 break 语句前是不是一样的。
```



## 堆排序

![img](..\source\img\heapSort.gif)



```c++
class Heap
{
public:
	Heap(std::vector<int> source) :
		m_heap_array{ source },
		len{ m_heap_array.size()-1 },
		capacity{ m_heap_array.size() }
	{
		for (int i = len/2-1; i >= 0; i--)
		{
			heap_adjust(i);
		}
		int len = this->len;
		while (len >= 0) {
			std::swap(m_heap_array[0], m_heap_array[len]);   //将堆顶元素与尾节点交换后，长度减1，尾元素最大
			len--;
			heap_adjust(0);   //再次对堆进行调整
		}
	}
private:
	void heap_adjust(int i)
	{
		int left_node;
		int right_node;
		int j;
		while ((left_node = 2*i+1) <=len)
		{
			right_node = left_node + 1;

			j = left_node;

			if (j < len && m_heap_array[left_node] < m_heap_array[right_node])   //右节点大于左节点
				j++;    //当前把"指针"指向右节点
			if (m_heap_array[i] < m_heap_array[j])   //将父节点与孩子节点交换（如果上面if为真，则arr[j]为右节点，如果为假arr[j]则为左节点）
				std::swap(m_heap_array[i], m_heap_array[j]);
			else
			{
				break;
			}
			i = j;
		}
	}

public:
	std::vector<int> m_heap_array;
	size_t len;
	size_t capacity;
};
```



[十大排序算法](https://blog.csdn.net/mengyujia1234/article/details/90179896)
