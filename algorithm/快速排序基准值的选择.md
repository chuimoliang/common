## 一种错误的方法

```
通常的、没有经过充分考虑的选择是将第一个元素做为"基准“。如果输入书随机的，那么这是可以接受的，但是如果输入是预排序的或是反序的，那么这样的”基准“就是一个劣质的分割，因为所以的元素不是被划入S1就是被划入S2。实际上，如果第一个元素用作”基准“而且输入是预先排序的，那么快速排序花费的时间将是二次的，可是实际上却没干什么事，因此，使用第一个元素作为”基准“是绝对糟糕的。
```

## 一种安全的方法

```
一种安全的方法是随机选取”基准“。这种策略是非常安全的，除非随机生成器有问题，但是随机数的生成一般是昂贵的，减少不了算法其余部分的平均运行时间。
```

## 三数中值分割法

```
一组N个数的中值是第[N/2]个最大的数。”基准“的最好选择是数组的中值。但是这很难算出，且减慢快速排序的速度。这样的中值的估计量可以通过随机选取三个元素并用它们的中值作为”基准”而得到。实际上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为“基准”。
```

## 实现三数中值分割方法

```c++
ElementType Median3(ElementType A[],int Left,int Right)
{
    int Center = (Left + Right) / 2;
    if(A[Left] > A[Center])
        Swap(&A[Left],&A[Center]);
    if(A[Left] > A[Right])
        Swap(&A[Left],&A[Right]);
    if(A[Center] > A[Right])
        Swap(&A[Center],&A[Right]);
        
    Swap(&A[Center],&A[Right - 1]);
    return A[Right - 1];
}
```

